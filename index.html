<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>MetaHamilton Cesium</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- CesiumJS (latest release CDN) -->
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Cesium.js"></script>

  <style>
    html, body, #cesiumContainer {
      height: 100%; width: 100%; margin: 0; padding: 0; overflow: hidden;
      font-family: sans-serif;
    }
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1000;
      background: rgba(255,255,255,0.9);
      padding: 8px 12px;
      border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
      max-width: 320px;
      font-size: 13px;
    }
    a.small { font-size: 12px; }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>
  <div id="overlay">
    <strong>Welcome to the MetaHamilton Cesium Viewer!</strong><br><br>
    <div id="status">Initializing...</div>
    <div style="margin-top:8px;">
      <a class="small" href="https://www.arcgis.com/home/item.html?id=bee5c01ae891442ebd1cf54894939bad" target="_blank">Open Map In ArcGIS</a>
      <p>Explore the map and click on highlighted features. Each feature can be toggled below.</p>
    </div>
  </div>

<script>
  (async function () {
    const ITEM_ID = 'bee5c01ae891442ebd1cf54894939bad';
    const statusEl = document.getElementById('status');

    Cesium.Ion.defaultAccessToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIzMmFhMjEwNy0wMzg2LTQ2YjctYTQzYS01NDRjYTIzOGQzZWEiLCJpZCI6MzUwMzY5LCJpYXQiOjE3NjA1MzY2OTd9.qE1UEvuWZ8zE-L18UevG-KvhGx8HDR6nCJCuJpYAQBA";

    // Create Cesium viewer
    const viewer = new Cesium.Viewer('cesiumContainer', {
      terrainProvider: await Cesium.createWorldTerrainAsync(),
      timeline: false,
      animation: false,
      shouldAnimate: false,
      baseLayerPicker: true,
      selectionIndicator: false,
    });

    // Keep reference to terrain provider for toggling
    const terrainProvider = await Cesium.createWorldTerrainAsync();
    viewer.terrainProvider = terrainProvider;

    // Setting non-bermuda imagery to openstreetmap
    viewer.imageryLayers.addImageryProvider(new Cesium.OpenStreetMapImageryProvider({
      url: 'https://a.tile.openstreetmap.org/'
    }));

    // Add Cesium OSM Buildings
    const osmBuildings = viewer.scene.primitives.add(
      await Cesium.createOsmBuildingsAsync()
    );


    // Add UI to toggle terrain and OSM buildings
    const terrainOsmToggleContainer = document.createElement('div');
    terrainOsmToggleContainer.style.marginTop = '8px';
    terrainOsmToggleContainer.innerHTML = '<strong>Toggle 3D:</strong> ';

    const toggleCheckbox = document.createElement('input');
    toggleCheckbox.type = 'checkbox';
    toggleCheckbox.id = 'toggle_terrain_osm';
    toggleCheckbox.checked = true; // default: enabled

    const toggleLabel = document.createElement('label');
    toggleLabel.htmlFor = 'toggle_terrain_osm';
    toggleLabel.textContent = ' Enable 3D Terrain & OSM Buildings';

    terrainOsmToggleContainer.appendChild(toggleCheckbox);
    terrainOsmToggleContainer.appendChild(toggleLabel);

    // Append it to overlay
    document.getElementById('overlay').appendChild(terrainOsmToggleContainer);

    toggleCheckbox.addEventListener('change', () => {
        if (toggleCheckbox.checked) {
            viewer.terrainProvider = terrainProvider;
            osmBuildings.show = true;
        } else {
            viewer.terrainProvider = new Cesium.EllipsoidTerrainProvider();
            osmBuildings.show = false;
        }
    });

    // --- PERFORMANCE TOGGLE UI ---
    const perfContainer = document.createElement('div');
    perfContainer.style.marginTop = '8px';
    perfContainer.innerHTML = '<strong>Performance Mode:</strong> ';

    const perfCheckbox = document.createElement('input');
    perfCheckbox.type = 'checkbox';
    perfCheckbox.id = 'toggle_perf_mode';
    perfCheckbox.checked = false; // default: off (high quality)

    const perfLabel = document.createElement('label');
    perfLabel.htmlFor = 'toggle_perf_mode';
    perfLabel.textContent = ' Enable Performance Mode';

    perfContainer.appendChild(perfCheckbox);
    perfContainer.appendChild(perfLabel);

    document.getElementById('overlay').appendChild(perfContainer);

    function setPerformanceMode(enabled) {
      const scene = viewer.scene;
      if (enabled) {
        scene.globe.maximumScreenSpaceError = 4;
        scene.globe.enableLighting = false;
        scene.postProcessStages.fxaa.enabled = false;
        scene.requestRenderMode = true;
        scene.maximumRenderTimeChange = Infinity;
        console.log("High performance mode enabled");
      } else {
        scene.globe.maximumScreenSpaceError = 2;
        scene.globe.enableLighting = true;
        scene.postProcessStages.fxaa.enabled = true;
        scene.requestRenderMode = false;
        console.log("High performance mode disabled");
      }
      viewer.scene.requestRender(); // refresh scene immediately
    }

    // Initialize with default
    setPerformanceMode(false);

    // Listen for user toggle
    perfCheckbox.addEventListener('change', () => {
      setPerformanceMode(perfCheckbox.checked);
    });



    // Load data here
    const geojsonUrls = [
      "resources/Buildings.geojson",
      "resources/Education_Facilities_(Points).geojson",
      "resources/Education_Facilities_(Polygons).geojson",
      "resources/Financial_Services_(Points).geojson",
      "resources/Financial_Services_(Polygons).geojson",
      "resources/Healthcare_Facilities.geojson",
      "resources/Parishes.json",
      "resources/Points_Interest_(Points).geojson",
      "resources/Points_Interest_(Polygons).geojson",
      "resources/Populated_Places_(Points).geojson",
      "resources/Roads_(Lines).geojson",
      "resources/Road_Surface_Quality.geojson",
      "resources/Storm_Tracks.geojson",
      "resources/Waterways_(Points).geojson",
      "resources/Waterways_(Polygons).geojson"
    ]

    const geojsonLayers = geojsonUrls.map(url => ({
      name: url.split('/').pop(),
      url,
      ds: null, // will be loaded on demand
      isLoaded: false,
      isLoading: false,
    }));

    const toggleContainer = document.createElement('div');
    toggleContainer.style.marginTop = '8px';
    toggleContainer.innerHTML = '<strong>Toggle Layers:</strong><br>';

    // Add simple CSS spinner
    const style = document.createElement('style');
    style.textContent = `
      .spinner {
        display: inline-block;
        width: 12px;
        height: 12px;
        border: 2px solid #ccc;
        border-top-color: #555;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
        vertical-align: middle;
        margin-left: 6px;
      }
      @keyframes spin { to { transform: rotate(360deg); } }
    `;
    document.head.appendChild(style);

    // For each layer, create checkbox + spinner + label
    geojsonLayers.forEach(layer => {
      const id = 'toggle_' + layer.name.replace(/\W/g, '_');
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.id = id;
      checkbox.checked = false; // start off
      checkbox.style.marginRight = '4px';

      const label = document.createElement('label');
      label.htmlFor = id;
      label.textContent = ' ' + layer.name.replace(/(\.geojson|\.json)$/i, '').replace(/_/g, ' ');

      const spinner = document.createElement('span');
      spinner.className = 'spinner';
      spinner.style.display = 'none';

      // Handle toggle
      checkbox.addEventListener('change', async () => {
        if (checkbox.checked) {
          if (!layer.isLoaded && !layer.isLoading) {
            layer.isLoading = true;
            spinner.style.display = 'inline-block';
            checkbox.disabled = true;
            statusEl.textContent = `Loading ${layer.name}...`;

            try {
              const ds = await Cesium.GeoJsonDataSource.load(layer.url, { clampToGround: true });
              viewer.dataSources.add(ds);
              layer.ds = ds;
              layer.isLoaded = true;
              statusEl.textContent = `Loaded ${layer.name}`;
            } catch (err) {
              console.error('Error loading GeoJSON:', layer.url, err);
              checkbox.checked = false;
              statusEl.textContent = `Failed to load ${layer.name}`;
            } finally {
              spinner.style.display = 'none';
              checkbox.disabled = false;
              layer.isLoading = false;
            }
          } else if (layer.isLoaded) {
            // Just show existing one
            layer.ds.show = true;
          }
        } else {
          // Unload when unchecked
          if (layer.isLoaded && layer.ds) {
            viewer.dataSources.remove(layer.ds, true);
            layer.ds = null;
            layer.isLoaded = false;
            statusEl.textContent = `Unloaded ${layer.name}`;
          }
        }
      });

      const wrapper = document.createElement('div');
      wrapper.style.display = 'flex';
      wrapper.style.alignItems = 'center';
      wrapper.style.gap = '4px';

      wrapper.appendChild(checkbox);
      wrapper.appendChild(label);
      wrapper.appendChild(spinner);
      toggleContainer.appendChild(wrapper);
    });

    // "Deselect All" and "Select All" buttons
    const deselectBtn = document.createElement('button');
    deselectBtn.textContent = 'Deselect All Layers';
    deselectBtn.style.marginTop = '8px';
    deselectBtn.style.display = 'block';
    deselectBtn.addEventListener('click', () => {
      geojsonLayers.forEach(layer => {
        const id = 'toggle_' + layer.name.replace(/\W/g, '_');
        const checkbox = document.getElementById(id);
        if (checkbox && checkbox.checked) {
          checkbox.checked = false;
          checkbox.dispatchEvent(new Event('change'));
        }
      });
    });

    const selectBtn = document.createElement('button');
    selectBtn.textContent = 'Select All Layers';
    selectBtn.style.marginTop = '4px';
    selectBtn.style.display = 'block';
    selectBtn.addEventListener('click', () => {
      geojsonLayers.forEach(layer => {
        const id = 'toggle_' + layer.name.replace(/\W/g, '_');
        const checkbox = document.getElementById(id);
        if (checkbox && !checkbox.checked) {
          checkbox.checked = true;
          checkbox.dispatchEvent(new Event('change'));
        }
      });
    });

    toggleContainer.appendChild(deselectBtn);
    toggleContainer.appendChild(selectBtn);

    document.getElementById('overlay').appendChild(toggleContainer);


    let lastSelected = null;

    viewer.selectedEntityChanged.addEventListener(entity => {
        // Reset previous selection
        if (lastSelected) {
            if (Cesium.defined(lastSelected.polygon)) {
                lastSelected.polygon.material = lastSelected.originalColor;
            }
            if (Cesium.defined(lastSelected.polyline)) {
                lastSelected.polyline.material = lastSelected.originalMaterial;
            }
            if (Cesium.defined(lastSelected.billboard)) {
                lastSelected.billboard.color = lastSelected.originalColor;
                lastSelected.billboard.pixelSize = lastSelected.originalSize;
                lastSelected.billboard.image = lastSelected.originalImage;
                lastSelected.billboard.scale = lastSelected.originalScale;
            }
            lastSelected = null;
        }

        if (!entity) return; // nothing selected

        lastSelected = entity;

        // Polygons
        if (Cesium.defined(entity.polygon)) {
            entity.originalColor = entity.polygon.material;
            entity.polygon.material = Cesium.Color.ORANGE.withAlpha(0.8); // color when selected
        }

        // Polylines
        if (Cesium.defined(entity.polyline)) {
            entity.originalMaterial = entity.polyline.material;
            entity.polyline.material = new Cesium.PolylineOutlineMaterialProperty({
                color: Cesium.Color.ORANGE,
                outlineColor: Cesium.Color.ORANGE,
                outlineWidth: 2
            });
        }

        if (Cesium.defined(entity.billboard)) {
          console.log('Billboard selected:', entity);
          entity.originalImage = entity.billboard.image;
          entity.originalScale = entity.billboard.scale;

          // Change the color using PinBuilder (orange pin)
          const pinBuilder = new Cesium.PinBuilder();
          const newPin = pinBuilder.fromColor(Cesium.Color.ORANGE, 48); // 48 = pixel height

          entity.billboard.image = newPin;
          entity.billboard.scale = 1.5; // increase size by 50%
      }
    });

    // Helper to set status text
    function setStatus(txt) { statusEl.textContent = txt; }

    // Try to fetch ArcGIS item JSON (this endpoint returns metadata for the item)
    setStatus('Fetching ArcGIS item metadata...');
    try {
      const itemMetaUrl = `https://www.arcgis.com/sharing/rest/content/items/${ITEM_ID}?f=json`;
      const res = await fetch(itemMetaUrl);
      if (!res.ok) throw new Error('HTTP ' + res.status);
      const itemJson = await res.json();

      // Show item title if available
      if (itemJson.title) {
        setStatus(`Item: ${itemJson.title}`);
      } else {
        setStatus('Item metadata fetched');
      }

      // Two likely properties that indicate a service URL:
      // - itemJson.url  (common for items that point to a service)
      // - itemJson.serviceItemId and/or itemJson.url in data or item data
      // We'll try the simple common paths first.
      let serviceUrl = itemJson.url || null;

      // If item references a hosted tile/service via itemData, try to fetch item data
      if (!serviceUrl) {
        setStatus('No direct service url in item metadata — checking item data...');
        try {
          const dataRes = await fetch(`https://www.arcgis.com/sharing/rest/content/items/${ITEM_ID}/data?f=json`);
          if (dataRes.ok) {
            const dataJson = await dataRes.json();
            // Common patterns: dataJson.service && dataJson.service.url
            if (dataJson.service && dataJson.service.url) {
              serviceUrl = dataJson.service.url;
            }
            // Or dataJson.layers -> first.layerDefinition && layer's url
            if (!serviceUrl && dataJson.operationalLayers && dataJson.operationalLayers.length) {
              for (const l of dataJson.operationalLayers) {
                if (l.url) { serviceUrl = l.url; break; }
                if (l.layerType === 'ArcGISTiledMapServiceLayer' && l.url) { serviceUrl = l.url; break; }
              }
            }
            // For tile layers there might be a tileInfo + tile URL template in resources
            if (!serviceUrl && dataJson.tileUrl) {
              serviceUrl = dataJson.tileUrl;
            }
          }
        } catch (e) {
          // non-fatal
          console.warn("Couldn't fetch item data:", e);
        }
      }

      // If we found a REST MapServer/TileServer-like URL, use ArcGisMapServerImageryProvider
      if (serviceUrl && (serviceUrl.toLowerCase().includes('/mapserver') || serviceUrl.toLowerCase().includes('/imageserver') || serviceUrl.toLowerCase().includes('/tileserver') || serviceUrl.toLowerCase().includes('/tiles'))) {
        setStatus('Found service URL — loading via ArcGisMapServerImageryProvider');
        try {
          // Use fromUrl (promised) if available (modern Cesium)
          const provider = await Cesium.ArcGisMapServerImageryProvider.fromUrl(serviceUrl);
          const layer = viewer.imageryLayers.addImageryProvider(provider);
          // Zoom to provider rectangle if present
          if (provider.rectangle) {
            viewer.camera.setView({ destination: provider.rectangle });
          } else {
            // otherwise fly to a reasonable place
            viewer.camera.flyHome(1.3);
          }
          setStatus('Finished Loading!');
        } catch (err) {
          console.error('ArcGisMapServerImageryProvider.fromUrl error', err);
          setStatus('Failed to load ArcGIS MapServer provider — check console. Trying UrlTemplate fallback...');
          // Fall through to fallback
          await tryUrlTemplateFallback(itemJson);
        }
      } else {
        // No explicit MapServer-like URL found — try to build a UrlTemplate from common patterns
        setStatus('No MapServer URL found — attempting tile-template fallback...');
        await tryUrlTemplateFallback(itemJson);
      }
    } catch (err) {
      console.error('Error while fetching item metadata:', err);
      setStatus('Could not fetch item metadata. You can manually provide the service URL below.');
      // Provide manual fallback instructions and allow user to manually add a provider
      createManualAddUI();
    }

    // --- helper functions ---

    async function tryUrlTemplateFallback(itemJson) {
      // Common tile template patterns used by ArcGIS: /tile/{z}/{y}/{x}
      // Some ArcGIS Online hosted tile layers use a tiles.arcgis.com domain with a /tiles/.../MapServer/tile/{z}/{y}/{x}
      // We can't reliably guess it for all items, so show a helpful UI that lets the user paste the MapServer or tile-template URL.
      setStatus('Tile-template fallback could not be auto-resolved. You can paste the MapServer or tile URL below.');

      createManualAddUI();
    }

    function createManualAddUI() {
      // Create a small input UI to let the user paste a service URL or tile template
      if (document.getElementById('manualUI')) return;
      const container = document.createElement('div');
      container.id = 'manualUI';
      container.style.marginTop = '8px';

      container.innerHTML = `
        <div style="margin-top:8px;">
          <label>Paste MapServer URL or tile template (eg. https://yourserver/MapServer or .../MapServer/tile/{z}/{y}/{x})</label><br>
          <input id="serviceUrlInput" style="width:100%; box-sizing:border-box; margin-top:4px;" placeholder="https://.../MapServer" />
          <div style="margin-top:6px;">
            <button id="addArcBtn">Add as ArcGIS MapServer</button>
            <button id="addTemplateBtn">Add as UrlTemplate</button>
          </div>
        </div>
      `;
      document.getElementById('overlay').appendChild(container);

      document.getElementById('addArcBtn').onclick = async () => {
        const url = document.getElementById('serviceUrlInput').value.trim();
        if (!url) return alert('Paste a URL first');
        setStatus('Attempting to load ArcGIS MapServer provider...');
        try {
          const provider = await Cesium.ArcGisMapServerImageryProvider.fromUrl(url);
          viewer.imageryLayers.addImageryProvider(provider);
          
          setStatus('Added ArcGIS MapServer layer: ' + url);
          if (provider.rectangle) viewer.camera.setView({ destination: provider.rectangle });
        } catch (e) {
          console.error(e);
          alert('Failed to add ArcGIS MapServer provider. See console for details.');
        }
      };

      document.getElementById('addTemplateBtn').onclick = () => {
        const templ = document.getElementById('serviceUrlInput').value.trim();
        if (!templ) return alert('Paste a URL template first');
        // Validate that it contains {x} {y} {z}
        if (!templ.includes('{x}') || !templ.includes('{y}') || !templ.includes('{z}')) {
          if (!confirm('Template does not include {x}/{y}/{z}. Continue anyway?')) return;
        }
        try {
          const provider = new Cesium.UrlTemplateImageryProvider({
            url: templ,
            maximumLevel: 20
          });
          viewer.imageryLayers.addImageryProvider(provider);
          setStatus('Added UrlTemplate imagery provider');
          viewer.camera.flyHome(1.2);
        } catch (e) {
          console.error(e);
          alert('Failed to add UrlTemplate provider. See console for details.');
        }
      };
    }

  })();
</script>
</body>
</html>
